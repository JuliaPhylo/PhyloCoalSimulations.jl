var documenterSearchIndex = {"docs":
[{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"using PhyloNetworks, PhyloPlots, PhyloCoalSimulations, RCall, DataFrames\nfigpath = joinpath(\"..\", \"assets\", \"figures\"); mkpath(figpath)\nfigname(x) = joinpath(figpath, x)","category":"page"},{"location":"man/mapping_genetree_to_network/#mapping-gene-trees-into-the-species-phylogeny","page":"mapping gene trees into the species network","title":"mapping gene trees into the species phylogeny","text":"","category":"section"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"Nodes in gene trees can be mapped to a node or an edge in the species phylogeny. Edges in gene trees can be mapped to an edge in the species phylogeny. Attributes of nodes and edges are used to carry this mapping information, as detailed in the documentation of function simulatecoalescent.","category":"page"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"We give examples below of how we may use this mapping information.","category":"page"},{"location":"man/mapping_genetree_to_network/#naming-internal-nodes","page":"mapping gene trees into the species network","title":"naming internal nodes","text":"","category":"section"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"First, it's useful to name internal nodes in the network, to which we can later map nodes in the gene tree.","category":"page"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"net = readTopology(\"((C:0.9,(B:0.2)#H1:0.7::0.6):0.6,(#H1:0.6,A:1):0.5);\");\nPhyloNetworks.nameinternalnodes!(net, \"I\"); # \"I\" is a prefix to name internal nodes\nwriteTopology(net)","category":"page"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"Notice the extra node names in the species phylogeny: I1, I2, and I3 at the root.","category":"page"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"Next, we use the option nodemapping=true when simulating gene trees, to ask for extra degree-2 nodes in gene trees. These nodes are created each time that a gene tree lineage crosses a node in the species phylogeny, that is, each time that a gene tree lineage crosses a speciation node or a hybridization node. We'll simulate a single tree here each time.","category":"page"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"using Random; Random.seed!(261); # to replicate randomness\ntree_regular = simulatecoalescent(net,1,1)[1];\nwriteTopology(tree_regular, round=true) # regular nodes only\nRandom.seed!(261); # to replicate the same coalescent simulation\ntree = simulatecoalescent(net,1,1; nodemapping=true)[1];\nwriteTopology(tree, round=true) # extra degree-2 nodes for mapping","category":"page"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"Notice that regular nodes in the gene tree (nodes that we get without the nodemapping option) don't have names. With the nodemapping option, there are many new nodes, all of degree-2, named after internal nodes in the network (I1, I2, I3). These extra degree-2 nodes and their names are sufficient to map the gene tree into the species network.","category":"page"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"The network is shown on the left below, with edges annotated by their numbers.","category":"page"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"R\"svg\"(figname(\"genetree_example1.svg\"), width=7.5, height=3); # hide\nR\"par\"(mar=[.1,.2,.1,.2], oma=[0,0,0,0.8]); R\"layout\"([1 2]); # hide\nplot(net, showedgenumber=true, shownodelabel=true, tipoffset=0.1);\nR\"mtext\"(\"species network\", side=3, line=-1);  # hide\nR\"mtext\"(\"grey: population edge number\", side=1, line=-1, cex=0.9);  # hide\nplot(tree, edgelabel=DataFrame(number=[e.number for e in tree.edge],\n                               label=[e.inCycle for e in tree.edge]),\n           edgelabelcolor=\"red4\", shownodelabel=true, tipoffset=0.1);\nR\"mtext\"(\"gene tree\", side=3, line=-1);  # hide\nR\"mtext\"(\"red (edge inCycle value): population a gene edge maps into\", side=1, line=-2, cex=0.9); # hide\nR\"mtext\"(\"black (node names): speciation/reticulation a node maps to\", side=1, line=-1, cex=0.9); # hide\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"(Image: example 1: degree-2 node names in gene tree)","category":"page"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"In the gene tree (right), each lineage is annotated by the network edge it maps into. Degree-2 nodes appear via their names, such that each horizontal line represents a series of gene lineages, separated from each other by degree-2 nodes. For example, the horizontal line tracing B's ancestry back in time maps into the network like this:","category":"page"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"from B, go back along edge 2\nmeet hybrid node H1, was inherited from the minor hybrid edge 5,\nfrom speciation node I2, trace back along edge 7,\nmeet the network's root node I3, trace back along the network's root edge 8 before coalescing with the ancestor of the other lineages (which have already coalesced by then).","category":"page"},{"location":"man/mapping_genetree_to_network/#cleaning-gene-trees","page":"mapping gene trees into the species network","title":"cleaning gene trees","text":"","category":"section"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"Almost all examples below use this mapping information via the extra degree-2 nodes and the extra edges between these nodes.","category":"page"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"But we may want to \"clean\" gene trees of their degree-2 nodes at some point. This can be done with the PhyloNetworks utility removedegree2nodes!, like this:","category":"page"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"PhyloNetworks.removedegree2nodes!(tree, true)","category":"page"},{"location":"man/mapping_genetree_to_network/","page":"mapping gene trees into the species network","title":"mapping gene trees into the species network","text":"The option true is to keep the root, even if it's of degree 2.","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"using PhyloNetworks, PhyloPlots, PhyloCoalSimulations\nfigpath = joinpath(\"..\", \"assets\", \"figures\"); mkpath(figpath)\nfigname(x) = joinpath(figpath, x)\nnet = readTopology(\"((C:0.9,(B:0.2)#H1:0.7::0.6)I1:0.6,(#H1:0.6::0.4,A:1.0)I2:0.5)I3;\");","category":"page"},{"location":"man/converting_coal2generation_units/#converting-between-units","page":"converting between units","title":"converting between units","text":"","category":"section"},{"location":"man/converting_coal2generation_units/#converting-edge-lengths-in-gene-trees","page":"converting between units","title":"converting edge lengths in gene trees","text":"","category":"section"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"In earlier examples, edge lengths in gene trees are simulated in coalescent units. These lengths can be converted into numbers of generations by multiplying by the effective population size Nₑ, since coalescent units are u = g/Nₑ. This can be done with different Nₑ's across different edges in the network, including the root edge.","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"info: diploid versus haploid Nₑ\nThe formula u = g/Nₑ uses the haploid effective population size Nₑ. For diploid taxa and autosomes, the haploid population size should be twice the diploid population size, for example.","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"Here is an example using the same network and simulated gene tree as earlier.","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"writeTopology(net)\nusing Random; Random.seed!(261); # as in mapping block\ntree = simulatecoalescent(net,1,1; nodemapping=true)[1];\nwriteTopology(tree, round=true)","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"(Image: example 1, same as in mapping section)","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"Let's set Nₑ to 1,000 in all populations, including the population above the root, except in edge 6. For this edge 6 (population leading to species A), let's set its Nₑ to 10,000.","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"Ne = Dict(e.number => 1_000 for e in net.edge);\nrootedgenumber = PhyloCoalSimulations.get_rootedgenumber(net)\npush!(Ne, rootedgenumber => 1_000); # add Ne for the edge above the network's root\nNe[6] = 10_000; # higher population size for the edge to species A\nNe\nwriteTopology(tree, round=true) # lengths in coalescent units: before unit conversion\n# convert edge lengths in gene tree from coalescent units to # generations\nfor e in tree.edge\n  e.length = round(e.length * Ne[e.inCycle]) # round: to get integers\nend\nwriteTopology(tree, round=true) # lengths in # of generations","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"Note that the simulation model assumes an infinite-Nₑ approximation, so the rescaling of edge lengths from coalescent units to number of generations will be imperfect for very small populations size. With the extreme Nₑ=1, coalescences should be immediate in a single generation back in time: g=1. Using the approximation, the simulated number of generations will typically be between 0-3 generations. But this is an extreme case, and the approximation should be very good even for moderate Nₑ's.","category":"page"},{"location":"man/converting_coal2generation_units/#number-of-generations-in-the-network-and-gene-trees","page":"converting between units","title":"number of generations in the network and gene trees","text":"","category":"section"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"If our input network has edge lengths in number of generations, then we need extra information to simulate under the coalescent: we need the effective size of each population. If the population size is constant, then g generations correspond to u = g/Nₑ coalescent units. If the population size varies along a single population edge, then the coalescence rate on that edge is determined by the harmonic mean overlineN_e of the population size: u = int_0^g 1N_e(t) dt = goverlineN_e.","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"Let's assume we have a network with number of generations as edge lengths:","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"net_gen = readTopology(\"((C:900,(B:200)#H1:700::0.6)I1:600,(#H1:600::0.4,A:1000)I2:500)I3;\");","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"and that we have a dictionary listing the (harmonic mean) population size along each edge of the species network, and also along the root edge above the network. Below, we simulate a population size for each population, from a uniform distribution between 1,000 and 1,500.","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"# uniform distribution between 1000 and 1500, that we can draw from later\nNe_distribution() = round(Int, 1000 + 500*Random.rand());\nNe = Dict(e.number => Ne_distribution() for e in net_gen.edge);\nrootedgenumber = PhyloCoalSimulations.get_rootedgenumber(net_gen)\npush!(Ne, rootedgenumber => Ne_distribution()); # Nₑ above the root\nNe","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"To visually check that we built our Nₑ dictionary correctly (and that our edge lengths are in generations, as we think), we can do this:","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"using DataFrames, RCall\nR\"svg\"(figname(\"net_genNe.svg\"), width=3.5, height=3); # hide\nR\"par\"(mar=[.5,1,.0,.1]);  # hide\nplot(net_gen, tipoffset=0.1, showedgelength=true, edgelabelcolor=\"red4\",\n          edgelabel=DataFrame(n=[e.number for e in net_gen.edge],\n                              l=[Ne[e.number] for e in net_gen.edge]));\nR\"text\"(x=1, y=2.5, Ne[rootedgenumber], adj=1, col=\"red4\");\nR\"mtext\"(\"red: Ne values\", side=1, line=-1.5, col=\"red4\");\nR\"mtext\"(\"black: edge lengths\", side=1, line=-0.5);\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"(Image: species net with Ne)","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"To simulate gene trees with edge lengths in generations, we can use a convenience wrapper function that takes Nₑ as an extra input to:","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"convert edge lengths to coalescent units in the species phylogeny,\nsimulate gene trees with lengths in coalescent units, then\nconvert gene trees to have lengths in number of generations:","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"genetree_gen = simulatecoalescent(net_gen,3,1, Ne; nodemapping=true);\nwriteMultiTopology(genetree_gen, stdout) # 3 gene trees, lengths in #generations","category":"page"},{"location":"man/converting_coal2generation_units/","page":"converting between units","title":"converting between units","text":"warning: Warning\nWhen Nₑ is given as an extra input to simulatecoalescent, edge lengths in the network are assumed to be in # of generations. If Nₑ is not given as input, then edge lengths are assumed to be in coalescent units.","category":"page"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"using PhyloNetworks, PhyloCoalSimulations\nnet = readTopology(\"((C:0.9,(B:0.2)#H1:0.7::0.6)I1:0.6,(#H1:0.6::0.4,A:1.0)I2:0.5)I3;\");\nusing Random; Random.seed!(261); # as in mapping block\ntree = simulatecoalescent(net,1,1; nodemapping=true)[1];","category":"page"},{"location":"man/more_examples/#example-uses","page":"more examples","title":"example uses","text":"","category":"section"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"We are re-using the same network and simulated tree as before:","category":"page"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"writeTopology(net)\nwriteTopology(tree, round=true)","category":"page"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"(Image: example 1, same as in mapping section)","category":"page"},{"location":"man/more_examples/#counting-deep-coalescences","page":"more examples","title":"counting deep coalescences","text":"","category":"section"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"The number of deep coalescences can be quantified as the number of \"extra\" lineages due to incomplete lineage sorting, that can be calculated from embedding the gene tree into the species phylogeny (see Maddison 1997 for species trees). For a speciation node in the species tree (e.g. I1), there are extra lineages in the gene tree, owing to a lack of coalescence, if there are more than 2 gene lineages mapping to this speciation node. For each hybridization node (e.g. H1), there are extra lineages if there are more than 1 gene lineage mapping to this hybridization node (because there's only 1 child edge descending from a hybridization node).","category":"page"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"We can count the number of extra lineages by counting the number of degree-2 nodes in the gene tree mapping to each node in the species network, then counting how many are \"extra\". In our gene tree above, we can do it this way:","category":"page"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"node_count = Dict(n.name => 0      for n in net.node if !n.leaf) # ignore leaves\nnode_hyb = Dict(n.name => n.hybrid for n in net.node if !n.leaf) # true/1 for hybrid nodes\n# traverse the gene tree, to count number of lineages entering each network node\nfor n in tree.node\n  (n.leaf || n.name == \"\") && continue # skip leaves and nodes without a name\n  node_count[n.name] += 1  # increment by 1 the number of lineages entering this node\nend\nnode_count # the 2 lineages entering I2 didn't coalesce until they reached I3\nfor node in keys(node_count) # modify our counts, to only keep the extras\n  node_count[node] = max(0, node_count[node] - ( node_hyb[node] ? 1 : 2))\nend\nnode_count # number of extra lineages: 1 extra entering I3\ndeepcoalescence = sum(values(node_count))","category":"page"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"On the particular gene tree we simulated, we counted 1 deep coalescence.","category":"page"},{"location":"man/more_examples/#number-of-lineages-inherited-via-gene-flow","page":"more examples","title":"number of lineages inherited via gene flow","text":"","category":"section"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"Our network has inheritance γ=0.4 on the minor edge, which we'll call the \"gene flow\" edge, and γ=0.6 on the major hybrid edge, parent to H1 on the major tree. But we may be interested in the realized proportion of lineages inherited from each parent at H1, realized in the gene trees we actually simulated. To do so, we can count the number of gene lineages that are mapped to each hybrid edge in the network.","category":"page"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"This mapping is stored in the edge attribute .inCycle. From the plot above, the minor \"gene flow\" edge is edge number 5 and the major hybrid edge has number 3. So we can count the gene lineages inherited via gene flow as the number of gene tree edges with inCycle equal to 5.","category":"page"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"If the gene trees have been saved to a file and later read from this file, then the .inCycle attributes are no longer stored in memory. In this case, we can retrieve the mapping information by the internal node names. The edges going through gene flow are those whose child node is named \"H1\" and parent node is named \"I2\".","category":"page"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"We use the first option with the .inCycle attribute below. We get that our one simulated gene tree was indeed inherited via gene flow:","category":"page"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"sum(e.inCycle == 5 for e in tree.edge)","category":"page"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"To make this more interesting, we can simulate many gene trees then count how many of their lineages were inherited via gene flow. If we ask for 2 individuals in species B, then each gene may have 2 lineages that enter the hybrid node H1, if the two B individuals fail to coalesce. In that case, it's possible that one individual lineage was inherited via gene flow, and the other not. We'll calculate the gene flow proportion among all these lineages. This proportion should be close (but not exactly equal) to the theoretical γ=0.4 from the network model.","category":"page"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"ngenes = 100\ngenetrees = simulatecoalescent(net, ngenes, Dict(\"B\"=>2, \"A\"=>1, \"C\"=>1); nodemapping=true);\nlength(genetrees)\nnlineages_geneflow = sum(sum(e.inCycle == 5 for e in gt.edge) for gt in genetrees)\nnlineages_major    = sum(sum(e.inCycle == 3 for e in gt.edge) for gt in genetrees)\n# realized γ, close to 0.4:\nproportion_geneflow = nlineages_geneflow / (nlineages_geneflow + nlineages_major)","category":"page"},{"location":"man/more_examples/#rate-variation-across-species","page":"more examples","title":"rate variation across species","text":"","category":"section"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"The gene trees resulting from simulatecoalescent have their edge lengths in coalescent units. One may want to convert them to substitutions per site, so as to simulate molecular sequences along these gene trees. The mapping information is important to allow for different rates of molecular evolution across different species. Here is an example to do this.","category":"page"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"We will use the Distributions package to simulate rates from a log-normal distribution across species, that is, across edges in the species network.","category":"page"},{"location":"man/more_examples/","page":"more examples","title":"more examples","text":"using Distributions\nlognormal_rate_dist = LogNormal(-0.125, 0.5) # μ = -σ²/2 to get a mean of 1.\nnetworkedge_rate = Dict(e.number => rand(lognormal_rate_dist) for e in net.edge)\n# add entry for the edge above the network's root. Find its number first.\nrootedgenumber = PhyloCoalSimulations.get_rootedgenumber(net)\npush!(networkedge_rate, rootedgenumber => rand(lognormal_rate_dist))\nwriteTopology(tree, round=true, digits=4) # before rate variation\n# multiply the length of each gene lineage by the rate of the species edge it maps into\nfor e in tree.edge\n  e.length *= networkedge_rate[e.inCycle]\nend\nwriteTopology(tree, round=true, digits=4) # after rate variation","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"using PhyloNetworks, PhyloCoalSimulations, RCall\nfigpath = joinpath(\"..\", \"assets\", \"figures\"); mkpath(figpath)\nfigname(x) = joinpath(figpath, x)\nusing Random; Random.seed!(432)","category":"page"},{"location":"man/getting_started/#getting-started","page":"getting started","title":"getting started","text":"","category":"section"},{"location":"man/getting_started/#installation","page":"getting started","title":"installation","text":"","category":"section"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"To install Julia see here and to install Julia packages, see here. To install PhyloCoalSimulations in the Julia REPL (as well as PhyloNetworks for many utilities), enter package mode with ] and do this:","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"add PhyloCoalSimulations\nadd PhyloNetworks","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"or do this in julian mode:","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"using Pkg\nPkg.add(\"PhyloCoalSimulations\")\nPkg.add(\"PhyloNetworks\")","category":"page"},{"location":"man/getting_started/#basic-simulation-example","page":"getting started","title":"basic simulation example","text":"","category":"section"},{"location":"man/getting_started/#example-network","page":"getting started","title":"example network","text":"","category":"section"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"For a basic example, we use a simple 3-species network plotted below. On the left, the plot shows the edge numbers (black) and the γ inheritance values (blue). On the right, the length of horizontal lines are proportional to edge lengths, and the plot shows the edge length values.","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"using PhyloNetworks\nnet = readTopology(\"((C:0.9,(B:0.2)#H1:0.7::0.6):0.6,(#H1:0.6,A:1):0.5);\");\nusing PhyloPlots\nR\"svg\"(figname(\"net3taxa.svg\"), width=6, height=3); # hide\nR\"par\"(mar=[.1,.1,.1,.1]); R\"layout\"([1 2]); # hide\nplot(net, showedgenumber=true, shownodelabel=true, showgamma=true, tipoffset=0.1);\nR\"mtext\"(\"in grey: edge numbers\", side=1, line=-1);  # hide\nplot(net, showedgelength=true, useedgelength=true, tipoffset=0.1);\nR\"mtext\"(\"in black: edge lengths\", side=1, line=-1);  # hide\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"(Image: 3-taxon network)","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"Note that this example network is not time consistent: the length of the path from the root to the hybridization node H1 is different depending if we go through the major edge (0.6+0.7=1.3) or the minor edge (0.5+0.6=1.1).","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"Coalescent simulations can be performed along such networks, also along non-ultrametric networks. If the network is ultrametric (time-consistent, and with all tips at the same distance from the root), then gene trees will also be ultrametric.","category":"page"},{"location":"man/getting_started/#basic-example:-simulate,-save-to-file,-plot","page":"getting started","title":"basic example: simulate, save to file, plot","text":"","category":"section"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"We use simulatecoalescent to simulate gene trees along this network. Below, we simulate 2 gene trees, with 1 individual per species.","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"trees = simulatecoalescent(net, 2, 1)","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"Branch lengths are assumed to be in coalescent units in the species network (number of generations / effective population size), and edge lengths in gene trees are also in coalescent units.","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"We can work with these gene trees within Julia with downstream code, and/or we can save them to a file:","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"writeMultiTopology(trees, stdout) # write them to standout output (screen here)\nwriteMultiTopology(trees, \"genetrees.phy\") # warning: will overwrite \"genetrees.phy\" if this file existed\nrm(\"genetrees.phy\") # hide","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"Let's plot these 2 gene trees. In the plots below, we annotate each edge with its attribute that tracked the network edge on which the coalescent event occured (where the gene tree lineage originated, going back in time). For example, the gene lineage that ends in A is always mapped to network edge 6, which is the number of the external edge to A in the network (see plot of network above on the left).","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"R\"svg\"(figname(\"genetrees_gettingstarted_1.svg\"), width=6, height=3); # hide\nR\"par\"(mar=[.1,.1,.1,.1]); R\"layout\"([1 2]); # hide\nusing DataFrames\nfor i in 1:2\n  gt = trees[i]\n  plot(gt, tipoffset=0.1,\n           edgelabel=DataFrame(number = [e.number  for e in gt.edge],\n                               label  = [e.inCycle for e in gt.edge]));\n  R\"mtext\"(\"gene $i\", line=-1) # hide\nend\nR\"mtext\"(\"numbers: network edge each gene lineage maps to, at time of coalescence.\\n8 = number of edge above the network root\", side=1, line=-1, outer=true);  # hide\nR\"dev.off()\" # hide\nnothing # hide","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"(Image: 3-taxon network)","category":"page"},{"location":"man/getting_started/#several-individuals-per-species","page":"getting started","title":"several individuals per species","text":"","category":"section"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"We can ask for more individuals. To simulate 3 individuals / species for example:","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"simulatecoalescent(net, 1, 3) # 1 gene tree only. 3 individuals in each species","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"We can also ask for varying numbers of individuals. For example, we simulate below 2 individuals in A and 1 individual in each of B and C, using a dictionary to map species to their number of individuals:","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"genetrees = simulatecoalescent(net, 1, Dict(\"A\"=>2, \"B\"=>1, \"C\"=>1));\nwriteTopology(genetrees[1])","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"We can set 0 individuals within a species to simulate missing data.","category":"page"},{"location":"man/getting_started/","page":"getting started","title":"getting started","text":"genetrees = simulatecoalescent(net, 3, Dict(\"A\"=>2, \"B\"=>1, \"C\"=>0));\nwriteMultiTopology(genetrees, stdout)","category":"page"},{"location":"","page":"home","title":"home","text":"CurrentModule = PhyloCoalSimulations","category":"page"},{"location":"#PhyloCoalSimulations","page":"home","title":"PhyloCoalSimulations","text":"","category":"section"},{"location":"","page":"home","title":"home","text":"PhyloCoalSimulations is a Julia package to simulate phylogenies under the coalescent. It depends on PhyloNetworks for the phylogenetic data structures, and manipulation of phylogenies.","category":"page"},{"location":"","page":"home","title":"home","text":"For a tutorial, see the manual:","category":"page"},{"location":"","page":"home","title":"home","text":"Pages = [\n    \"man/getting_started.md\",\n    \"man/mapping_genetree_to_network.md\",\n    \"man/converting_coal2generation_units.md\",\n    \"man/more_examples.md\",\n]\nDepth = 3","category":"page"},{"location":"","page":"home","title":"home","text":"References: upcoming","category":"page"},{"location":"#functions","page":"home","title":"functions","text":"","category":"section"},{"location":"","page":"home","title":"home","text":"Most functions are internal (not exported).","category":"page"},{"location":"","page":"home","title":"home","text":"","category":"page"},{"location":"","page":"home","title":"home","text":"Modules = [PhyloCoalSimulations]","category":"page"},{"location":"#PhyloCoalSimulations.coalescence_edge-NTuple{4, Any}","page":"home","title":"PhyloCoalSimulations.coalescence_edge","text":"coalescence_edge(edge1, edge2, number, populationid)\n\nCreate a coalescence between edges 1 and 2: with a new parent node n numbered number and a new parent edge e above the parent node, of length 0 and numbered number. Both n.inCycle and e.inCycle are set to populationid.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloCoalSimulations.convert2tree!-Tuple{PhyloNetworks.Node}","page":"home","title":"PhyloCoalSimulations.convert2tree!","text":"convert2tree!(rootnode)\n\nReturn a network with all nodes and edges that can be reached from rootnode. Warning: Assumes that edges are correctly directed (with correct isChild1 attribute) and that the graph is a tree. This is not checked.\n\nIf the root node is still attached to an incomplete root edge, this edge & node are first disconnected.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloCoalSimulations.get_rootedgenumber-Tuple{Any}","page":"home","title":"PhyloCoalSimulations.get_rootedgenumber","text":"get_rootedgenumber(network)\n\n1 + maximum of 0 and of all the network's edge numbers: can be used as a unique identifier of the edge above the network's root.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloCoalSimulations.initializetip","page":"home","title":"PhyloCoalSimulations.initializetip","text":"initializetip(species::AbstractString, individual::AbstractString,\n              number::Integer, delim=\"\"::AbstractString, len=0.0)\n\nCreate a leaf node and a pendant edge of length len, incident to each other, both numbered number. Return the pendant edge. The leaf name is made by concatenating species, delim and individual.\n\n\n\n\n\n","category":"function"},{"location":"#PhyloCoalSimulations.initializetip-2","page":"home","title":"PhyloCoalSimulations.initializetip","text":"initializetip(speciesnode::Node, nindividuals::Integer,\n              number::Integer, delim, len=0.0)\n\nVector of pendant leaf edges, with leaves named after speciesnode, and numbered with consecutive number IDs starting at number. If nindividuals is 1, then the leaf name is simply the species name. Otherwise, then the leaf names include the individual number and the default delimiter is _. For example, if the species name is s then leaf names are: s_1, s_2, etc. by default.  Pendant leaf edges have inCycle set to the number of the corresponding edge in the species network.\n\n\n\n\n\n","category":"function"},{"location":"#PhyloCoalSimulations.map2population!-NTuple{4, Any}","page":"home","title":"PhyloCoalSimulations.map2population!","text":"map2population!(forest, population_node, populationid, nextlineageID)\n\nExtend each incomplete edge in the forest with a new degree-2 node n and a new incomplete edge e, with the following information to map n and e into the species phylogeny:\n\ne.inCycle is set to populationid, and\nn.name is set to population_node.name if this name is non-empty, or string(population_node.number) otherwise (with any negative sign replaced by the string \"minus\").\n\ne.number and n.number are set to nextlineageID, which is incremented by 1 for each incomplete edge in the forest.\n\nThe forest is updated to contain the newly-created incomplete edges, replacing the old incomplete (and now complete) edges.\n\nOutput: nextlineageID, incremented by the number of newly created degree-2 lineages.\n\nexample\n\njulia> using PhyloNetworks; net = readTopology(\"(A:1,B:1);\");\n\njulia> leafA = net.node[1]; edge2A_number = net.edge[1].number;\n\njulia> f = PhyloCoalSimulations.initializetip(leafA, 2, 4); # 2 edges, numbered 4 & 5\n\njulia> PhyloCoalSimulations.map2population!(f, leafA, edge2A_number, 6)\n8\n\njulia> length(f)\n2\n\njulia> f[2]\nPhyloNetworks.Edge:\n number:7\n length:0.0\n attached to 1 node(s) (parent first): 7\n\njulia> [e.node[1].name for e in f]\n2-element Vector{String}:\n \"A\"\n \"A\"\n\n\n\n\n\n","category":"method"},{"location":"#PhyloCoalSimulations.simulatecoal_onepopulation!","page":"home","title":"PhyloCoalSimulations.simulatecoal_onepopulation!","text":"simulatecoal_onepopulation!(lineagelist, population_length, nextlineageID,\n                           populationID=-1)\n\nSimulate the coalescent process within a single population of length given in coalescent units, starting from lineages in lineagelist. This list should be a vector of incomplete edges, that is, edges incident to a single node only.\n\nVector of incomplete edges, whose lengths have been increased, is modified in place. New nodes and their parent edges are created by coalescent events, numbered with consecutive integers starting at nextlineageID.\n\nOutput: nextlineageID, incremented by number of new lineages.\n\nIn lineages, edge lengths are also considered in coalescent units.\n\nThe newly created nodes and edges have their .inCycle attribute set to populationID, so as to track the mapping of gene lineages to populations in the species phylogeny.\n\nexamples\n\njulia> PhyloCoalSimulations.simulatecoal_onepopulation!([], 2.0, 1)\n1\n\njulia> e1 = PhyloCoalSimulations.initializetip(\"s\",\"1\",1,\"\",0.1);\n\njulia> e2 = PhyloCoalSimulations.initializetip(\"s\",\"2\",2,\"\",0.2);\n\njulia> forest = [e1,e2]\n2-element Vector{PhyloNetworks.Edge}:\n PhyloNetworks.Edge:\n number:1\n length:0.1\n attached to 1 node(s) (parent first): 1\n\n PhyloNetworks.Edge:\n number:2\n length:0.2\n attached to 1 node(s) (parent first): 2\n\njulia> using Random; Random.seed!(7690);\n\njulia> PhyloCoalSimulations.simulatecoal_onepopulation!(forest, Inf, 3);\n\njulia> PhyloCoalSimulations.convert2tree!(forest[1].node[1])\nPhyloNetworks.HybridNetwork, Rooted Network\n2 edges\n3 nodes: 2 tips, 0 hybrid nodes, 1 internal tree nodes.\ntip labels: s2, s1\n(s2:0.502,s1:0.402);\n\n\n\n\n\n\n","category":"function"},{"location":"#PhyloCoalSimulations.simulatecoalescent-Tuple{PhyloNetworks.HybridNetwork, Integer, Any, Any}","page":"home","title":"PhyloCoalSimulations.simulatecoalescent","text":"simulatecoalescent(net, nloci, nindividuals, populationsize;\n    nodemapping=false, round_generationnumber=true)\n\nSimulate nloci gene trees with nindividuals from each species under the multispecies network coalescent, along network net, whose branch lengths are assumed to be in number of generations. populationsize should be a single number, assumed to be the (haploid) effective population size Nₑ, constant across the species phylogeny. Alternatively, populationsize can be a dictionary mapping the number of each edge in net to its Nₑ, including an extra edge number for the population above the root of the network.\n\nCoalescent units are then calculated as u=g/Nₑ where g is the edge length in net (number of generations), and the coalescent model is applied using the infinite-population-size approximation.\n\nOutput: vector of gene trees with edge lengths in number of generations, calculated as g=uNₑ and then rounded to be an integer, unless round_generationnumber is false.\n\nwarning: Warning\nWhen populationsize Nₑ is not provided as input, all edge lengths are in coalescent units. When populationsize is given as an argument, all edge lengths are in number of generations. The second method (using # generation and Nₑ as input) is a wrapper around the first (using coalescent units).\n\njulia> using PhyloNetworks\n\njulia> net = readTopology(\"(A:500,B:500);\"); # branch lengths of 100 generations\n\njulia> Ne = Dict(e.number => 1_000 for e in net.edge);\n\njulia> rootedgenumber = PhyloCoalSimulations.get_rootedgenumber(net)\n3\n\njulia> push!(Ne, rootedgenumber => 2_000) # Ne for population above the root\nDict{Int64, Int64} with 3 entries:\n  2 => 1000\n  3 => 2000\n  1 => 1000\n\njulia> using Random; Random.seed!(54321); # for replicability of example below\n\njulia> genetrees = simulatecoalescent(net, 2, 1, Ne);\n\njulia> writeMultiTopology(genetrees, stdout) # branch lengths: number of generations\n(B:546.0,A:546.0);\n(B:3155.0,A:3155.0);\n\n\n\n\n\n\n","category":"method"},{"location":"#PhyloCoalSimulations.simulatecoalescent-Tuple{PhyloNetworks.HybridNetwork, Integer, Any}","page":"home","title":"PhyloCoalSimulations.simulatecoalescent","text":"simulatecoalescent(net, nloci, nindividuals; nodemapping=false)\n\nSimulate nloci gene trees with nindividuals from each species under the multispecies network coalescent, along network net whose branch lengths are assumed to be in coalescent units (ratio: number of generations / effective population size). The coalescent model uses the infinite-population-size approximation.\n\nOutput: vector of gene trees, of length nloci.\n\nnindividuals can be a single integer, or a dictionary listing the number of individuals to be simulated for each species.\n\nIf nodemapping is true, each simulated gene tree is augmented with degree-2 nodes that can be mapped to speciation or hybridization events. The mapping of gene tree nodes & edges to network edges is carried by the .inCycle attribute. The mapping of gene tree nodes to network nodes is carried by the .name attribute. Namely:\n\nA degree-3 node (1 parent + 2 children) represents a coalescent event that occurred along a population edge in net. Its .inCycle attribute is set to the number of that network population edge. Its parent edge has its .inCycle attribute also set to the number of the population edge that it originated from.\nThe gene tree's root node (of degree 2) represents a coalescent event along the network's root edge. Its .inCycle attribute is the number assigned to the network's root edge, which is set by get_rootedgenumber as the maximum edge number + 1.\nA leaf (or degree-1 node) represents an individual. It maps to a species in net. The individual leaf name is set to the species name if nindividuals is 1. Otherwise, its name is set to speciesname_i where i is the individual number in that species. Its inCycle attribute is the default -1.\nA non-root degree-2 node represents a speciation or hybridization and maps to a population node in net. Its inCycle attribute is the default -1. Its name is set to network node name, if it exists. If the network node has no name, the gene tree node is given a name built from the network node number.\n\nAssumptions:\n\nnet must have non-missing edge lengths and γ values.\nIf nindividuals is a dictionary, it must have a key for all species, with the same spelling of species names in its keys as in the tip labels of net.\n\nexamples\n\njulia> using PhyloNetworks\n\njulia> net = readTopology(\"(A:1,B:1);\"); # branch lengths of 1 coalescent unit\n\njulia> using Random; Random.seed!(54321); # for replicability of examples below\n\njulia> simulatecoalescent(net, 2, 1) # 2 gene trees, 1 individual/species\n2-element Vector{HybridNetwork}:\n PhyloNetworks.HybridNetwork, Rooted Network\n2 edges\n3 nodes: 2 tips, 0 hybrid nodes, 1 internal tree nodes.\ntip labels: B, A\n(B:1.023,A:1.023);\n\n PhyloNetworks.HybridNetwork, Rooted Network\n2 edges\n3 nodes: 2 tips, 0 hybrid nodes, 1 internal tree nodes.\ntip labels: B, A\n(B:2.328,A:2.328);\n\n\njulia> simulatecoalescent(net, 1, 3)[1] # 1 gene tree, 3 individuals/species\nPhyloNetworks.HybridNetwork, Rooted Network\n10 edges\n11 nodes: 6 tips, 0 hybrid nodes, 5 internal tree nodes.\ntip labels: B_2, B_1, B_3, A_3, ...\n(((B_2:0.12,B_1:0.12):2.39,B_3:2.51):0.692,(A_3:0.518,(A_2:0.461,A_1:0.461):0.057):2.684);\n\njulia> simulatecoalescent(net, 1, Dict(\"A\"=>2, \"B\"=>1))[1] # 2 individuals in A, 1 in B\nPhyloNetworks.HybridNetwork, Rooted Network\n4 edges\n5 nodes: 3 tips, 0 hybrid nodes, 2 internal tree nodes.\ntip labels: B, A_2, A_1\n(B:2.801,(A_2:0.344,A_1:0.344):2.457);\n\n\njulia> Random.seed!(21);\n\njulia> tree1 = simulatecoalescent(net,2,2; nodemapping=true)[1]; # first gene tree only\n\njulia> writeTopology(tree1, round=true)\n\"((B_1:1.0)minus2:0.301,(((A_2:0.11,A_1:0.11):0.89)minus2:0.148,(B_2:1.0)minus2:0.148):0.153);\"\n\njulia> PhyloNetworks.nameinternalnodes!(net, \"I\"); writeTopology(net)\n\"(A:1.0,B:1.0)I1;\"\n\njulia> tree1 = simulatecoalescent(net,2,2; nodemapping=true)[1]; writeTopology(tree1, round=true)\n\"(((B_2:0.214,B_1:0.214):0.786)I1:0.168,((A_2:1.0)I1:0.008,(A_1:1.0)I1:0.008):0.16);\"\n\njulia> printNodes(net)\nnode leaf  hybrid hasHybEdge name inCycle edges'numbers\n1    true  false  false      A    -1      1   \n2    true  false  false      B    -1      2   \n-2   false false  false      I1   -1      1    2   \n\njulia> printNodes(tree1)\nnode leaf  hybrid hasHybEdge name inCycle edges'numbers\n10   false false  false           3       8    9   \n8    false false  false      I1   -1      5    8   \n5    false false  false           2       4    3    5   \n4    true  false  false      B_2  -1      4   \n3    true  false  false      B_1  -1      3   \n9    false false  false           3       7    6    9   \n7    false false  false      I1   -1      2    7   \n2    true  false  false      A_2  -1      2   \n6    false false  false      I1   -1      1    6   \n1    true  false  false      A_1  -1      1   \n\njulia> [(tree_edge_number = e.number, pop_edge_number = e.inCycle) for e in tree1.edge]\n9-element Vector{NamedTuple{(:tree_edge_number, :pop_edge_number), Tuple{Int64, Int64}}}:\n (tree_edge_number = 8, pop_edge_number = 3)\n (tree_edge_number = 5, pop_edge_number = 2)\n (tree_edge_number = 4, pop_edge_number = 2)\n (tree_edge_number = 3, pop_edge_number = 2)\n (tree_edge_number = 9, pop_edge_number = 3)\n (tree_edge_number = 7, pop_edge_number = 3)\n (tree_edge_number = 2, pop_edge_number = 1)\n (tree_edge_number = 6, pop_edge_number = 3)\n (tree_edge_number = 1, pop_edge_number = 1)\n\n\n\n\n\n","category":"method"}]
}
